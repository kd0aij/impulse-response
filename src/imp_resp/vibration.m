pkg load optim
pkg load signal
pkg load mapping
addpath("./loaders:./lib");
close all;
clear all;

%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_2K_1inst/flight1/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_2K_1inst/bench2/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/200hz/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/60hz/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/chirp/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/chirp_50_1000_30/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/chirp_50_250_30/log3/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/200hz/weight_pad/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/180hz/weight_pad/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/180hz/orig_weight_pad/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/180hz/orig_new/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/125hz/weight_pad/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/130hz/weight_pad/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/135hz/weight_pad/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/1100hz/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/60hz/weight_pad/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/5hz/weight_pad/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/30hz/weight_pad/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/30hz/orig_new/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/click/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/chirp_orig_20_180_new/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/chirp_20_180_new/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/chirp_150_200/orig/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/chirp_150_200/uniform/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/noise/uniform/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1KHz_synth/audacity/noise/orig/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1Khz/all_samp/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1Khz/all_samp/180hz/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/500Hz/180hz/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/500Hz/450hz/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/250Hz/180hz/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/250Hz/100hz/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/250Hz/noise_floor/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/250Hz/noise_floor/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/S250/flight1/";
default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/S250/flight3/";
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/S250/bench_gyro/";

%startTime = 40
%endTime = 60
%startTime = 40
%endTime = 60
%default_basePath = "/home/markw/gdrive/flightlogs/fast_gyro/1Khz/flt1/";
%startTime = 40
%endTime = 60

rad2deg = 180/pi;

# set default run parameters
# desired uniform sample rate in Hz; should be less than average sample rate
sampRate = 250

# set to true when start/endTime are correct
rangeSelected = 0;
# length in seconds of impulse response plot
impLen = 1.5

# path to CSV files
fflush (stdout);
basePath = default_basePath;

# CSV files generated by u2log2csv.py are prefixed by "logname_"
# process the first ".ulg" file we find in the specified directory
files = readdir(basePath);
for i = [1:size(files)(1)]
  r = cell2mat(strfind(files(i), ".ulg"));
  if (r > 0) 
    prefix = [cell2mat(files(i))(1:r-1) '_']
    [info,err,msg] = stat([basePath files{i}]);
    logsize = info.size
    break 
  endif
endfor

# load the accelerometer data
#[a0t, accel0] = loadAccel_filt(prefix, 0, basePath);
[a0t, accel0] = loadAccel_int(prefix, 0, basePath);
#[a0t, accel0] = loadAccel_raw(prefix, 0, basePath);
#[a0t, accel0] = loadGyro_int(prefix, 0, basePath);
#[a0t, accel0] = loadSC_gyro(prefix, 0, basePath);

nsamples = size(accel0)(1);
sigRange = [1:nsamples];
logduration = (a0t(end) - a0t(1))
printf("log data rate: %6.1f Kbytes/sec\n", 1e-3 * logsize / logduration);

# find timespan of data
if (!exist('startTime') | !exist('endTime'))
  startTime = a0t(1)
  endTime = a0t(end)
else
  # find index span of gyro data
  startOffset = 1;
  while (a0t(startOffset) < startTime) startOffset++; endwhile
  endOffset = startOffset;
  while (a0t(endOffset) < endTime) endOffset++; endwhile
  sigRange = [startOffset:endOffset];
endif

figNum = 1;
figure(figNum++, "Position", [1,200,1200,480]);
subplot(2,1,1);
plot(a0t, accel0(:,1), "-r", a0t, accel0(:,2), "-g", a0t, accel0(:,3), "-b");
axis("tight"); title("raw data extents");
xlabel("seconds");
grid("on"); grid("minor");

while (true)
  subplot(2,1,2);
  plot(a0t(sigRange), accel0(sigRange,1), "-r", a0t(sigRange), accel0(sigRange,2), "-g", a0t(sigRange), accel0(sigRange,3), "-b");
  axis("tight"); title("raw data subset");
  xlabel("seconds");
  grid("on"); grid("minor");

  newStart = input("enter new startTime (return when done): ", "s");
  if length(newStart) == 0
    break; 
  else
    startTime = str2num(newStart);
  endif;
  endTime = input("new endTime: ");

  # find index span of gyro data
  startOffset = 1;
  while (a0t(startOffset) < startTime) startOffset++; endwhile
  endOffset = startOffset;
  while (a0t(endOffset) < endTime) endOffset++; endwhile
  sigRange = [startOffset:endOffset];
endwhile

# analyze integration intervals and leave a complete accel data structure in the workspace
[samp_seq, at, a_interval] = loadFullAccel(basePath, prefix, sigRange);
%[samp_seq, at, a_interval] = loadFullGyro(basePath, prefix, sigRange);
nsamp = length(samp_seq);

filename = [basePath prefix "sensor_accel_0.csv"];
printf ("accel data log file: %s, data struct accdata\n", filename);
accdata = tdfread(filename);
acct = accdata.timestamp(sigRange) / 1e6;
acct -= acct(1);
dts = accdata.integral_dt(sigRange);
printf("accelerometer integration interval analysis\n");
printf("min: %f msec, freq: %f Hz\n", 1e-3*min(dts), 1e6 / min(dts));
printf("max: %f msec, freq: %f Hz\n", 1e-3*max(dts), 1e6 / max(dts));
printf("mean: %f msec, freq: %f Hz\n", 1e-3*mean(dts), 1e6 / mean(dts));

figure(figNum++, "Position", [1,300,1200,200]);
plot(acct-acct(1), dts, '.');
title("integration intervals");
hgsave([basePath "/int_intervals.ofig"])


# analyze logging intervals and dropouts
printf("log interval analysis\n");
[average, variance, deltas, drop_lengths, drops] = ...
  interval_analysis(acct);
printf("average log rate: %f Hz\n", 1 / average);
ndrops = length(drop_lengths)
if ndrops > 0  
  avgdrop = mean(drop_lengths)
  mindrop = min(drop_lengths)
  maxdrop = max(drop_lengths)
  total_drop = sum(drop_lengths)
  percent_drop = 100 * total_drop / (endTime - startTime)
endif

x_integral_sub = accdata.x_integral(sigRange);
y_integral_sub = accdata.y_integral(sigRange);
z_integral_sub = accdata.z_integral(sigRange);
dt_sub = accdata.integral_dt(sigRange);

figure(figNum++, "Position", [1,400,1200,600]);
subplot(3,1,1);
plot(acct, (1e6 * x_integral_sub ./ dt_sub), '.-',
    acct, 5e2 * x_integral_sub, 'o',
    acct(drops), 5e2 * x_integral_sub(drops) - .1, 'x');
title("x accel data");
if ndrops > 0  
  legend("int/dt", "int", "drop", "Location", "northeast");
else
  legend("int/dt", "int", "Location", "northeast");
endif
subplot(3,1,2);
plot(acct, (1e6 * y_integral_sub ./ dt_sub), '.-',
    acct, 5e2 * y_integral_sub, 'o',
    acct(drops), 5e2 * y_integral_sub(drops) - .1, 'x');
title("y accel data");
subplot(3,1,3);
plot(acct, (1e6 * z_integral_sub ./ dt_sub), '.-',
    acct, 5e2 * z_integral_sub, 'o',
    acct(drops), 5e2 * z_integral_sub(drops) - .1, 'x');
title("z accel data");
hgsave([basePath "/acceldata.ofig"])

xintsub = 5e2 * accdata.x_integral(sigRange);
xsub = 1e6 * accdata.x_integral(sigRange) ./ accdata.integral_dt(sigRange);

yintsub = 5e2 * accdata.y_integral(sigRange);
ysub = 1e6 * accdata.y_integral(sigRange) ./ accdata.integral_dt(sigRange);

zintsub = 5e2 * accdata.z_integral(sigRange);
zsub = 1e6 * accdata.z_integral(sigRange) ./ accdata.integral_dt(sigRange);

# resample to uniform rate, over the time range [startTime, endTime]
[a0tu, accel0u] = resample2(startTime, endTime, a0t, accel0, sampRate);

xvar = var(accel0u(:,1))
yvar = var(accel0u(:,2))
zvar = var(accel0u(:,3))

# get FFT and calculate frequency span
fftLen = size(accel0u)(1)
accel_fft = fft(accel0u - mean(accel0u));
nyquist_freq = sampRate/2
freq_res = sampRate / fftLen
# ignore DC term
index_range = [2:ceil(fftLen/2)];
freq_range = -1 + index_range * sampRate / fftLen;

%# construct complete sample sequence at 1KHz sample rate
%duration = (endTime - startTime)
%nrecs = length(accdata.int_count(sigRange))
%nsamp = sum(accdata.int_count(sigRange))
%act_samp_rate = nsamp / duration
%samp_seq = -10 * ones(nsamp,3);
%samp_times = startTime + [0:nsamp-1]' * a_interval;
%j = 1;
%for i = sigRange
%  if (accdata.int_count(i) >= 1)
%    samp_seq(j,1)   = accdata.x_in_0_(i);
%    samp_seq(j,2)   = accdata.y_in_0_(i);
%    samp_seq(j++,3) = accdata.z_in_0_(i);
%  endif
%  if (accdata.int_count(i) >= 2)
%    samp_seq(j,1)   = accdata.x_in_1_(i);
%    samp_seq(j,2)   = accdata.y_in_1_(i);
%    samp_seq(j++,3) = accdata.z_in_1_(i);
%  endif
%  if (accdata.int_count(i) >= 3)
%    samp_seq(j,1)   = accdata.x_in_2_(i);
%    samp_seq(j,2)   = accdata.y_in_2_(i);
%    samp_seq(j++,3) = accdata.z_in_2_(i);
%  endif
%  if (accdata.int_count(i) >= 4)
%    samp_seq(j,1)   = accdata.x_in_3_(i);
%    samp_seq(j,2)   = accdata.y_in_3_(i);
%    samp_seq(j++,3) = accdata.z_in_3_(i);
%  endif
%  if (accdata.int_count(i) >= 5)
%    samp_seq(j,1)   = accdata.x_in_4_(i);
%    samp_seq(j,2)   = accdata.y_in_4_(i);
%    samp_seq(j++,3) = accdata.z_in_4_(i);
%  endif
%endfor

figure(figNum++, "Position", [1,300,1200,300]);
plot(at, samp_seq);
legend(["x";"y";"z"]);
axis("tight"); grid on;
title("accelerometer signals");
xlabel("seconds");
ylabel("m/sec/sec");

zindex_range = [1:ceil(nsamp/2)]';
zfreq_range = zindex_range * 1000 / nsamp;
zseq_fft = fft(samp_seq - mean(samp_seq));
zseq_fft = abs(zseq_fft(zindex_range,:));

%% integrate and decimate
%oddsamples = [1:2:nsamp];
%evensamples = [2:2:nsamp];
%ndsamp = length(evensamples);
%zdec = .5 * (samp_seq(oddsamples(1:ndsamp)) + samp_seq(evensamples));
%zdindex_range = [2:ceil(ndsamp/2)];
%zdfreq_range = -1 + zdindex_range * 500 / ndsamp;
%zdseq_fft = fft(zdec - mean(zdec));
%zdseq_fft = abs(zdseq_fft(zdindex_range));

x_fft = abs(accel_fft(index_range,1));
y_fft = abs(accel_fft(index_range,2));
z_fft = abs(accel_fft(index_range,3));
fscl = max(z_fft);

figure(figNum++, "Position", [1,300,1200,300]);
plot(
%     freq_range, 20 * log10(x_fft / fscl), 'r',
%     freq_range, 20 * log10(y_fft / fscl), 'g',
     freq_range, 20 * log10(z_fft / fscl), 'b'
     );
title("vibration spectrum");
%legend("x", "y", "z", "Location", "northwest");
xlabel("Hz");
axis("tight"); grid on;
hgsave([basePath "/vibration_spectrum.ofig"])

absmax = max(max(zseq_fft));
figure(figNum++, "Position", [1,300,1200,300]);
plot(
     zfreq_range, 20 * log10(zseq_fft / absmax)
%     ,
%     zdfreq_range, 20 * log10(zdseq_fft / max(zdseq_fft)), 'g.'
     );
title("zseq spectrum");
legend(["x";"y";"z"]);
xlabel("Hz");
axis([0 500 -60 0]);
grid on;
hgsave([basePath "/zseq_spectrum.ofig"])

figure(figNum++, "Position", [1,300,1200,900]);
subplot(3,1,1);
plot(zfreq_range, 20 * log10(zseq_fft(:,1) / absmax), 'r');
axis([0 500 -60 0]);
grid on;
xlabel("Hz"); ylabel("dB");
title("vibration spectrum x");
subplot(3,1,2);
plot(zfreq_range, 20 * log10(zseq_fft(:,2) / absmax), 'g');
axis([0 500 -60 0]);
grid on;
xlabel("Hz"); ylabel("dB");
title("vibration spectrum y");
subplot(3,1,3);
plot(zfreq_range, 20 * log10(zseq_fft(:,3) / absmax), 'b');
axis([0 500 -60 0]);
grid on;
xlabel("Hz"); ylabel("dB");
title("vibration spectrum z");
hgsave([basePath "/vibration_spectrum2.ofig"])

save ("-binary", [basePath "workspace.bin"])
